package reactor;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.nio.file.Paths;import java.nio.file.StandardOpenOption;import java.util.Iterator;/** * Created by demopoo on 2017/8/23. */public class MainHttpClientPro implements Runnable  {    private SocketChannel socketChannel;    private Selector selector;    private FileChannel fileChannel;    private  long tlen;    public static void main(String[] args){        MainHttpClientPro mainHttpClientPro = new MainHttpClientPro();        new Thread(new MainHttpClientPro()).start();    }    private MainHttpClientPro(){        try {            this.fileChannel = FileChannel.open(Paths.get("/Users/demopoo/Desktop/big.png"), StandardOpenOption.READ);            this.socketChannel = SocketChannel.open();            this.socketChannel.connect(new InetSocketAddress("127.0.0.1",9898));            this.socketChannel.configureBlocking(false);            this.selector = Selector.open();            socketChannel.register(selector, SelectionKey.OP_CONNECT);            this.tlen = fileChannel.size();//            sendPic();        }catch (IOException ex){            ex.printStackTrace();        }    }    public void run() {        try {            while (true){                while (this.selector.select() > 0){                    Iterator<SelectionKey> sks = selector.selectedKeys().iterator();                    while (sks.hasNext()){                        SelectionKey sk = sks.next();                        if (sk.isReadable()){                            SocketChannel sc = (SocketChannel)sk.channel();                            ByteBuffer bf = ByteBuffer.allocateDirect(1024);                            int len = 0;                            if ((len=sc.read(bf)) !=-1){                                bf.flip();                                System.out.println("接收到的数据:"+new String(bf.array()));                                bf.clear();                            }                        }else if (sk.isConnectable()){                            sendPic(sk);                        }else if (sk.isWritable()){                            ByteBuffer byteBuffer = (ByteBuffer) sk.attachment();                            SocketChannel socketChannel = (SocketChannel) sk.channel();                            if (byteBuffer != null){                                socketChannel.write(byteBuffer);                                if (byteBuffer.hasRemaining()){                                    byteBuffer.compact();                                    sk.attach(byteBuffer);                                    sk.interestOps(sk.interestOps() | sk.OP_WRITE);                                }else {                                    sk.attach(null);                                    sk.interestOps(sk.interestOps() &~ sk.OP_WRITE);                                }                            }                        }                    }                }            }        }catch (IOException ex){            ex.printStackTrace();        }    }    /**     * 发送图片数据     */    public void sendPic(SelectionKey sk){        try {            int socketSize = this.socketChannel.socket().getSendBufferSize();            ByteBuffer bf = ByteBuffer.allocate(socketSize+267);//1500            ByteBuffer byteBuffer = ByteBuffer.allocate(socketSize);//1233            int len = 0;            int i = 0;            while ((len = fileChannel.read(byteBuffer)) != -1){                prepareMultiPostHeader("big.png",tlen,byteBuffer,bf);                byteBuffer.clear();                bf.flip();                socketChannel.write(bf);                //表示第一次数据未发送完整                if (bf.hasRemaining()){                    bf.compact();                    sk.attach(bf);                    sk.interestOps(sk.interestOps() | sk.OP_WRITE);                }else {                    sk.attach(null);                    sk.interestOps(sk.interestOps() &~ sk.OP_WRITE);                }                bf.clear();            }            byteBuffer.clear();            int rlen = 0;            while ((rlen = socketChannel.read(byteBuffer)) != -1){                byteBuffer.flip();            }            if (rlen == -1){                fileChannel.close();                socketChannel.close();            }        }catch (IOException ex){            ex.printStackTrace();        }    }    /**     * 构建http 请求报文     * @param fileName 上传附件名称     * @param len 附件总长度     * @return     */    public static ByteBuffer prepareMultiPostHeader(String fileName,long len,ByteBuffer byteBuffer,ByteBuffer bf){        long systemCurrentMilis = System.currentTimeMillis();        StringBuffer stringBuffer = new StringBuffer();        stringBuffer.append("POST / HTTP/1.1").append("\r\n");        stringBuffer.append("Accept-Language").append(": ").append("zh-cn").append("\r\n");        stringBuffer.append("Content-Type:multipart/form-data;boundary=-----------------------------7d").append(systemCurrentMilis).append("\r\n");        stringBuffer.append("Content-Length").append(": ").append(len).append("\r\n");//\r\n        stringBuffer.append("-------------------------------7d").append(systemCurrentMilis).append("\r\n");        stringBuffer.append("Content-Disposition: form-data; name=\"file\"; filename=\"big.png\"").append("\r\n\r\n");        bf.put(stringBuffer.toString().getBytes());        bf.put(byteBuffer.array());//        bf.put(("-------------------------------7d"+systemCurrentMilis+"--").getBytes());        return bf;    }}