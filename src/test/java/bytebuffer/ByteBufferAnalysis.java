package bytebuffer;import sun.misc.Unsafe;import sun.nio.ch.DirectBuffer;import java.nio.ByteBuffer;import java.util.TreeSet;import java.util.concurrent.locks.LockSupport;/** * Created by demopoo on 2017/8/27. */public class ByteBufferAnalysis {    public static void main(String[] args){        byte[] bt = new byte[1024];        ByteBuffer byteBuffer = ByteBuffer.wrap(bt,10,100);//ByteBuffer.allocateDirect(1024);        String str = "justdoit,myalwaysfriends!";        byteBuffer.put(str.getBytes());        byteBuffer.mark();        byteBuffer.put("thankyou".getBytes());        byteBuffer.get();        System.out.println(new String(bt));////        byteBuffer.put(0,(byte)'D');//        System.out.println(new String(bt));//        byteBuffer.flip();//        byteBuffer.rewind();//        System.out.println(1);        /****************limit() limit(int newLimit) position() position(int newPosition)*///        int limit = byteBuffer.limit();//        byteBuffer.limit(100);////        int position = byteBuffer.position();//        byteBuffer.position(100);        /****************clear()*///        byteBuffer.clear();//        byteBuffer.put(0,(byte)'D');////        System.out.println(new String(byteBuffer.array()));        /****************put(byte[] bt,int offset,int length)*///        byteBuffer.position(0);//        byteBuffer.put("--demopoo".getBytes(),0,6);//        System.out.println(new String(byteBuffer.array()));        /****************put(byte[] bt)*///        byteBuffer.position(0);//        byteBuffer.put("--demopoo".getBytes());//        System.out.println(new String(byteBuffer.array()));        /****************put(byte bt)*///        System.out.println(new String(byteBuffer.array()));//        byteBuffer.put((byte)'D');//        System.out.println(new String(byteBuffer.array()));        /****************put(Index index,byte bt)*///        System.out.println(new String(byteBuffer.array()));//        byteBuffer.put(0,(byte)'D');//        System.out.println(new String(byteBuffer.array()));        /****************get()  get(Index index)*///        System.out.println(byteBuffer.position());//        byte bt = byteBuffer.get(0);//        System.out.println(new String(new byte[]{bt}));//        byte bt1 = byteBuffer.get(1);//        System.out.println(new String(new byte[]{bt1}));//        System.out.println(byteBuffer.position());//        byteBuffer.flip();        /******************get(byte[] bt ,int offset,int leng)*///        int pos = byteBuffer.position();//        System.out.println(new String(byteBuffer.array()));////        byteBuffer.reset();//        int smallpos = byteBuffer.position();//        byte[] bt = new byte[50];//        byteBuffer.get(bt,0,(pos-smallpos));//        System.out.println(new String(bt));        /******************get(byte[] bt)*///        byte[] bt = new byte[330];//        byteBuffer.position(0);//or byteBuffer.flip()//        byteBuffer.get(bt);//        System.out.println(new String(bt));    }}/** 关于ByteByffer 用法总结*   | 关于 get 的用法*       |1、get() 从当前position位置读取一个byte的数据，并将position+1*       |2、get(int index) 读取bytebuffer 里面下标为index的byte，且position 不变*       |3、get(byte[] bt,int offset,int length) 从当前position开始读，读取length个byte 存入到bt 里面下标从offset 到 offset+length的区域*       |4、get(byte[] bt) 从当前byteBuffer 的position位置取byte[] 长度的内容村到byte[] 里。如果byte[]长度大于Bytebuffer 则报错 BufferUnderflowException**   | 关于 put 的用法*       |1、put(Index index,byte bt) 往ByteBuffer 下标为 index 的位置插入一个字节byte ，并替换掉以前的字节数据。且position的位置不变*       |2、put(byte bt)往ByteBuffer 的position位置插入一个字节，并且position + 1(并替换掉以前的字节数据)*       |3、put(byte[] bt) 往ByteBuffer 的position位置插入字节数据bt,且position + bt.length(注：插入字节数据的总长度不能大于 byteBuffer的长度)(并替换掉以前的字节数据)*       |4、put(byte[] bt,int offset,int length) 往bytebuffer 的position 位置插入长度为length的数据，且position+length，且数据来之 byte[] ，起始位置为offset ，且长度为length（并替换掉以前的字节数据）**   | 关于 compact（) 的用法：*       |1、目的，压缩缓冲区*       |2、过程：            |2.1、将position 到 limit之间的数据移至 0 到 limit - position 的位置            |2.2、且 position的位置移至 limit-position 的位置，且limit 移至 capacity处（可以理解为，此时bytebuffer处与往里写数据状态）* *      pos                             limit         capacity        |---------------------------------|------------|*       发送了部分数据后*                      pos              limit         capacity        ----------------|-----------------|------------|*       调用compact（）压缩后*                          pos                   capacity(limit)        --------------------|-------------------------|**    | 关于 hasRemaining 用法。判断bytebuffer里面是否还有数据可读 （position < limit）boolean**    | 关于 Remaining 用法。计算bytebuffer 里面还有多少数据可读（limit - position ）int**    | 关于 flip() 用法. limit 至为 当前position的位置，position 至为 0。且 mark = -1 （重置）**    | 关于 clear() 用法.position =0,limit = capacity ,mark = -1 .但是bytebuffer里面的数据任然存在，不受影响**    | 关于 reset() 用法。要陪同mark()一起使用。当调用reset方法是，position的位置重置到mark 标记的位置，也就是mark的值**    | 关于 limit() limit(int newLimit) position() position(int newPosition) 用法。不带参数表示获取limit 或 position。带参数表示设置limit 或 position的值**    | 关于rewind() position = 0，mark  = -1 ，limit 不变。如果先调用flip 再调用rewind 而bytebuffer 不会发生任何变化**    | 关于allocate(int capacity)用法。在JVM堆内存冲分配一块长度为capacity的byte数据区域，作为缓冲区。用于存储byte数组**    | 关于allocateDirect（int capacity） 用法。该方法是直接在操作系统的内存区分配一块长度为capacity的区域存储byte[].*      作用：减少JVM内存区域 和 操做系统内存区域的复制操作，减少开销。*      副作用：直接在操作系统内存区域进行内存分配的开销较大，*      适用场景：1、大文的复制操作 2、缓冲区需要经常使用，且长期存在（减少直接缓冲区的创建次数和JVM 内存和native内存的复制次数**    | 关于 wrap(byte[] bt) 的用法。相当于新建一个capacity 等于 bt.length 的缓冲区。且bt 里面的内容变化，会影响缓冲区的变化，反之毅然**    | 关于 wrap(byte[] bt,int offset,int length) 的用法。相当于新见一个初始 position 位置为offset，且limit = leng+offset 的缓冲区.。且bt 里面的内容变化，会影响缓冲区的变化，反之毅然*** */